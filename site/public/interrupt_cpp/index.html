<!DOCTYPE html>
<html ⚡>
  <head>
    <meta charset="utf-8">
<meta name="pinterest" content="nopin">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="theme-color" content="#263238">

<meta name="generator" content="Hugo 0.40.1" />

<link rel="apple-touch-icon" href="https://focused-pare-3555cf.netlify.com/images/logo.png">


<link rel="canonical" href="https://focused-pare-3555cf.netlify.com/interrupt_cpp/">


    
    <link href="https://fonts.googleapis.com/css?family=Lobster|Lato:400,700" rel="stylesheet">
    
    <title>Interrupts in standard C&#43;&#43; - Software development musings</title>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
    
    
    
<meta name="description" content="So you have this new microcontroller you want to use C&amp;#43;&amp;#43; on. How do we know your interrupt code behaves with modern compilers and newer standards? The evolution of compilers means they are getting better at optimizing standard compliant code. The side effect is that non-compliant code just gets more and more likely to be broken as time and compiler versions passes by. Interrupts are a foreign concept to the standard.">

<meta property="og:title" content="Interrupts in standard C&#43;&#43; - Software development musings">
<meta property="og:type" content="article">
<meta property="og:url" content="https://focused-pare-3555cf.netlify.com/interrupt_cpp/">
<meta property="og:image" content="https://focused-pare-3555cf.netlify.com/images/default.png">
<meta property="og:site_name" content="Software development musings">
<meta property="og:description" content="So you have this new microcontroller you want to use C&amp;#43;&amp;#43; on. How do we know your interrupt code behaves with modern compilers and newer standards? The evolution of compilers means they are getting better at optimizing standard compliant code. The side effect is that non-compliant code just gets more and more likely to be broken as time and compiler versions passes by. Interrupts are a foreign concept to the standard.">
<meta property="og:locale" content="ja_JP">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="Software development musings">
<meta name="twitter:url" content="https://focused-pare-3555cf.netlify.com/interrupt_cpp/">
<meta name="twitter:title" content="Interrupts in standard C&#43;&#43; - Software development musings">
<meta name="twitter:description" content="So you have this new microcontroller you want to use C&amp;#43;&amp;#43; on. How do we know your interrupt code behaves with modern compilers and newer standards? The evolution of compilers means they are getting better at optimizing standard compliant code. The side effect is that non-compliant code just gets more and more likely to be broken as time and compiler versions passes by. Interrupts are a foreign concept to the standard.">
<meta name="twitter:image" content="https://focused-pare-3555cf.netlify.com/images/default.png">


<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "NewsArticle",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id":"https://focused-pare-3555cf.netlify.com/"
    },
    "headline": "Interrupts in standard C&#43;&#43; - Software development musings",
    "image": {
      "@type": "ImageObject",
      "url": "https://focused-pare-3555cf.netlify.com/images/default.png",
      "height": 800,
      "width": 800
    },
    "datePublished": "2018-07-23T00:00:00JST",
    "dateModified": "2018-07-23T00:00:00JST",
    "author": {
      "@type": "Person",
      "name": "Software development musings"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Software development musings",
      "logo": {
        "@type": "ImageObject",
        "url": "https://focused-pare-3555cf.netlify.com/images/logo.png",
        "width": 600,
        "height": 60
      }
    },
    "description": "So you have this new microcontroller you want to use C&#43;&#43; on. How do we know your interrupt code behaves with modern compilers and newer standards?
 The evolution of compilers means they are getting better at optimizing standard compliant code. The side effect is that non-compliant code just gets more and more likely to be broken as time and compiler versions passes by.
 Interrupts are a foreign concept to the standard."
  }
</script>


    <style amp-custom>
      html { font-size: 18px;}@media (max-width: 768px) { html { font-size: 15px; }}body { font-family: Lato,'Hiragino Kaku Gothic Pro',メイリオ,Meiryo,sans-serif; font-size: inherit; margin: 0; color: #263238;}html, body { margin: 0;}a { text-decoration: none; color: #e91e63;}p { margin: 0;}ul,ol { margin: 0; padding: 0;}h1, h2, h3, h4, h5, h6 { margin: 0; font-weight: 700;}h1 { font-size: 1.8rem; line-height: 2rem; margin: 1.5rem 0; }h2 { font-size: 1.4rem; line-height: 2rem; margin: 1.5rem 0; }h3 { font-size: 1.2rem; line-height: 1.5rem; margin: 1.5rem 0; }h4, h5, h6 { font-size: 1rem; line-height: 1.5rem; margin: 1.5rem 0; }.clearfix::after { content: ''; display: block; clear: both;}main { display: block;}/* Layouts */.l-header { padding: .5rem 0; margin-bottom: 2rem; border-bottom: 1px dashed #cfd8dc; text-align: center;}.l-footer { font-size: .8rem; padding: 1rem 0; border-top: 1px dashed #cfd8dc;}.l-container { max-width: 42rem; margin: 0 auto; padding: 0 1rem;}/* Parts:logo */.p-logo { font-family: Lobster, cursive;}.p-logo a { color: #000; font-size: 1.6rem; line-height: 2rem;}/* Parts:section */section { border-top: 2px solid #eceff1; padding: 1.5rem 0;}section>header { text-transform: uppercase; font-weight: 700; margin-bottom: 2rem; text-align: center;}section>header span { display: inline-block; background-color: #000; color: #fff; letter-spacing: 3px; font-size: .7rem; padding: .5rem .75rem;}/* Parts:facts */.p-facts { list-style: none; font-size: .8rem; margin-bottom: 1rem;}.p-facts:last-child { margin-bottom: 0;}.p-facts li { display: inline-block; margin-right: .5rem; text-transform: uppercase;}.p-facts li header { margin-bottom: .25rem; font-weight: 700;}.p-facts li header a { color: #000; text-decoration: underline;}.p-facts li li { display: inline-block; margin-right: .5rem;}.p-facts li li::after { content: ',';}.p-facts li li:last-child::after { content: '';}/* Parts:crumb */.p-crumb { list-style: none; margin-bottom: 1rem; font-size: .8rem; text-transform: uppercase; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}.p-crumb:last-child { margin-bottom: 0;}.p-crumb li { display: inline;}.p-crumb li::after { content: '›'; margin: 0 .5rem;}.p-crumb li:last-child::after { content: '';}/* Parts:page-title */.p-page-title { margin-bottom: 2rem;}.p-page-title .title { margin-bottom: .5rem;}/* Parts:share */.p-share { margin-bottom: 1.5rem;}.p-share a { display: inline-block; text-align: center; padding: .5rem .5rem; margin-right: .25rem; font-size: .6rem; background-color: #eceff1; font-weight: 700k}.p-share a.ht { color: #00a4de; }.p-share a.fb { color: #3b5998; }.p-share a.tw { color: #1da1f2; }.p-share a.gp { color: #dd4b39; }.p-share a.ln { color: #00c300; }.p-share a.ht::before { content: 'Hatena'; }.p-share a.fb::before { content: 'Facebook'; }.p-share a.tw::before { content: 'Twitter'; }.p-share a.gp::before { content: 'Google+'; }.p-share a.ln::before { content: 'LINE'; }/* Parts:terms */.p-terms { padding-left: 2rem;}/* Parts:paginator */.p-paginator { text-align: center; margin-bottom: 3rem; padding-top: 2rem;}.p-paginator a { display: inline-block; border: 2px solid #eceff1; color: #263238; line-height: 2rem; padding: 0 1rem;}/* Parts:article */.p-articles { list-style: none;}.p-articles>li { margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px dashed #cfd8dc;}.p-articles>li:last-child { border-bottom: none; padding-bottom: 0;}.p-articles.thin>li { margin-bottom: 1rem; padding-bottom: 1rem;}article .article-header { display: table-cell; height: 6rem; vertical-align: middle;}article .title { margin: 0; margin-bottom: .5rem; font-size: 1.4rem; line-height: 2rem;}article .title a { color: #000;}article .header-wrapper { margin-bottom: 1.5rem;}article .thumbnail { display: block; background-position: center; background-size: cover; background-image: url(https://focused-pare-3555cf.netlify.com/images/default.jpg); width: 6rem; height: 6rem; border-radius: 50%; box-shadow: 0 0 3px 0 #333 inset; float: left; margin-right: 1rem;}article .summary { margin-bottom: 1.5rem;}article .readmore { text-align: center;}article .readmore a { font-size: .8rem; color: #000; text-decoration: underline;}article.li.sm .header-wrapper { margin-bottom: 0;}.article-body h2 { padding: 1rem 0; border-bottom: 2px solid #eceff1;}.article-body h2:first-child { margin-top: 0; }.article-body h3 { color: #cddc39;}.article-body h4 { border-left: solid .25rem #cddc39; padding: 0 .5rem;}.article-body p { margin: 1.5rem 0; line-height: 1.5rem;}.article-body a { text-decoration: underline;}.article-body ul,.article-body ol { padding-left: 1.5rem;}.article-body code { display: inline-block; font-family: Menlo, consolas, monospace; background-color: #eceff1; font-size: .8rem; padding: 0 .5rem; line-height: 1.5rem;}.article-body pre { margin: 1.5rem 0; padding: 1.5rem; font-size: .8rem; background-color: #263238; color: #fff; overflow: auto;}.article-body pre code { background-color: transparent;}.article-body blockquote { margin: 1.5rem 0; padding: .5rem 0; font-size: .8rem; border-top: 1px solid #eceff1; border-bottom: 1px solid #eceff1; color: #607d8b;}.article-body blockquote p { margin: .5rem 0; line-height: 1rem;}.article-body strong { box-shadow: 0 -.5rem 0 0 #f06292 inset;}.article-body em { font-style: normal; font-weight: 700; color: #ff5722;}.article-body figure { margin: 1.5rem -2rem; }.article-body figure.left,.article-body figure.right { width: 15rem; height: 12rem; margin-top: 0; margin-left: 0; margin-right: 0;}.article-body figure.left { float: left; margin-right: 1rem; margin-left: -2rem; }.article-body figure.right { float: right; margin-left: 1rem; margin-right: -2rem; }@media (max-width: 768px) { .article-body figure { margin: 1.5rem -1rem; } .article-body figure.left, .article-body figure.right { float: none; margin: 0 -1rem; width: auto; height: auto; }}.article-body figcaption { padding: .5rem 0; font-size: .8rem; text-align: center;}.article-body figcaption a { color: #263238;}

       .article-ae82d399b20db4fbf2c1159dee28f6c6 .thumbnail { background-image: url(https://focused-pare-3555cf.netlify.com/images/thumbnail.jpg);  } 
    </style>
  </head>

  <body>
    
    
    

    <header class="l-header">
      <div class="l-container">
        <div class="h-logo p-logo">
          <a href="https://focused-pare-3555cf.netlify.com/" class="h-logo">Software development musings</a>
        </div>
      </div>
    </header>

    <main>
      
<div class="l-container">
  <article class="single article-8d539ac9b483e99a18e4fbb90dd32d19">
  <div class="header-wrapper">
    <a href="https://focused-pare-3555cf.netlify.com/interrupt_cpp/" class="thumbnail" title="Interrupts in standard C&#43;&#43;"></a>
    <header class="article-header">
      <div class="clearfix">
        <h1 class="title">Interrupts in standard C&#43;&#43;</h1>
        <ul class="p-facts">
          <li><time datetime="2018-07-23T00:00:00JST">Jul 23, 2018</time></li>
          
          
        </ul>
      </div>
    </header>
  </div>

  <aside class="p-share">
  <a href="http://b.hatena.ne.jp/add?mode=confirm&url=https%3a%2f%2ffocused-pare-3555cf.netlify.com%2finterrupt_cpp%2f&title=Interrupts%20in%20standard%20C%2b%2b" title="はてなブックマーク" class="ht" target="_blank" rel="nofollow"></a>
  <a href="http://www.facebook.com/sharer.php?u=https%3a%2f%2ffocused-pare-3555cf.netlify.com%2finterrupt_cpp%2f&t=Interrupts%20in%20standard%20C%2b%2b" title="Facebookでシェア" class="fb" target="_blank" rel="nofollow"></a>
  <a href="http://twitter.com/intent/tweet?url=https%3a%2f%2ffocused-pare-3555cf.netlify.com%2finterrupt_cpp%2f&text=Interrupts%20in%20standard%20C%2b%2b&tw_p=tweetbutton" title="Twitterでシェア" class="tw" target="_blank" rel="nofollow"></a>
  <a href="https://plus.google.com/share?url=https%3a%2f%2ffocused-pare-3555cf.netlify.com%2finterrupt_cpp%2f" title="Google Plusでシェア" class="gp" target="_blank" rel="nofollow"></a>
  <a href="http://line.me/R/msg/text/?Interrupts%20in%20standard%20C%2b%2b https%3a%2f%2ffocused-pare-3555cf.netlify.com%2finterrupt_cpp%2f" title="LINEでシェア" class="ln" target="_blank" rel="nofollow"></a>
</aside>


  <div class="article-body"><div class="paragraph">
<p>So you have this new microcontroller you want to use C&#43;&#43;  on. How do we know your
interrupt code behaves with modern compilers and newer standards?</p>
</div>
<div class="paragraph">
<p>The evolution of compilers means they are getting better at optimizing standard
compliant code. The side effect is that non-compliant code just gets more and more likely
to be broken as time and compiler versions passes by.</p>
</div>
<div class="paragraph">
<p>Interrupts are a foreign concept to the standard. So we will have to rely on toolchain specific extensions to make interrupts workable and can you truly say you know your
environment?</p>
</div>
<div class="paragraph">
<p>When C&#43;&#43; 11 was adopted we got the new memory model. Suddenly we could reason about threads in a
standard compliant way and code written for one system could be used in others without having
to worry about portability issues relating to threads. In the best of worlds at least.</p>
</div>
<div class="paragraph">
<p>So one desired property when we start wrinting non-standard code for interrupts is to at least know the constraints we are operating under. If so, we could grab some standard library,
review the code to see if it fulfills these and if it checks out, use it.</p>
</div>
<div class="paragraph">
<p>In the long run we could also start building interrupt related primitives that taste and feel like normal C/C&#43;&#43;  code. We hide everything system dependent in them and use them with normal
portable code. Much like mutexes can make single threaded code become safe in a multi-threading environment.</p>
</div>
<div class="paragraph">
<p>Also, a reason for this is to allow your code to exist in several systems. There are many
reasons to want your microcontroller code to also work as a simulation in your Linux system.
Initially maybe only as a testing and code quality tool, but later it could be a migration
path to more powerful hardware.</p>
</div>
<div class="sect1">
<h2 id="_interrupts_modeled_as_a_thread">Interrupts modeled as a thread</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So let us start by assuming we can treat interrupt based code as a thread. What would it give us?
An interrupt breaks the running of a thread, does its thing and then return to the thread. From the thread perspective this is no different from being scheduled from a kernel. This should be the same.</p>
</div>
<div class="paragraph">
<p>However, an interrupt usually runs on the same stack as the thread. It can not be blocked since
that would block the entire thread. In particular it can not try to acquire mutexes if there
is a chance that mutex is locked from the thread below it.
The only way to have a thread protecting itself from a thread is to disable its start. Once
that is done you can change some data atomically and then reenable the interrupt.</p>
</div>
<div class="sect2">
<h3 id="_thread_interrupt_start_stop">Thread interrupt start / stop.</h3>
<div class="paragraph">
<p>When a thread is started, it is started from some other thread via the std::thread object constructor. This is a synchronization point between these 2 threads. In constrast, an
interrupt is a hardware induced context switch. Here we will need some explicit synchronization
between the running thread and the newly started interrupt. Conversely when the interrupt
ends, if it changed some variables, it needs to synchronize with the thread before the
thread can access these variables.</p>
</div>
<div class="paragraph">
<p>An additional note on the startup. The compiler generally only expects main() to be the top level function. If it can deduce that nobody is calling an interrupt function it can remove it. There is a need to somehow tell the compiler that there might be calls to the interrupt service function, potentially from another thread, especially if link time optimization is enabled. This will prevent that type of optimizations.</p>
</div>
<div class="paragraph">
<p>Once the interrupt have started it is very similar to a thread. It itself can be interrupted from higher level interrupts. In particular the same rules about synchronization of data between threads should hold for interrupt/thread communication.</p>
</div>
<div class="paragraph">
<p>So, could we build up a synchronization primitive similar to a Mutex, but intended for
protecting sections of code between an interrupt and a thread, we could write very normal looking code. This primitive would need to have a system dependent implementation to handle
the protection and synchronization needs for a particular platform.</p>
</div>
</div>
<div class="sect2">
<h3 id="_generalized_model_of_interrupts">Generalized model of interrupts</h3>
<div class="paragraph">
<p>Often interrupts comes in several priorities. Also in RTOSes there are thread priorities where
a higher priority thread will strictly run before a lower priority thread. If we ban context
switching between equal level threads and interrupts we can actually run this on a single stack.
In this setting I will use the word <em>Task</em> to refer to either a thread or an interrupt. They
form a continous space separated by priority where interrupts are always higher prioritized than threads.</p>
</div>
<div class="paragraph">
<p>This is a fully assymmetric system. In this case our primitive should allow a low level Task to set up a critical section where it knows it can change data without being interrupted. The other side, can just run on without risk of interruption from below. On the other hand, it might also need to protect itself from above.
The other requirement it has, is to ensure synchronization of data between tasks. We approximate that all our tasks can be viewed as standard C&#43;&#43;  threads so the normal sychronization rules between threads should apply.</p>
</div>
<div class="paragraph">
<p>Lets start designing a new primitive called a 'Cover'. It is the analog of a mutex in the assymmetric case. Mutex is short for 'mutual exclusion' and there is nothing mutual here. The name 'cover' means it should cover, shield or protect accesses to shared variables between task.</p>
</div>
<div class="paragraph">
<p>To implement this, we will need the standard tools to perform synchronization between threads.
These are part of the C&#43;&#43; standard in terms of std::atomic_thread_fence which can be had in
acquire and release variants. Getting a cover means doing an acquire fence and releasing the cover means doing a release fence.
This will allow us to operate within the boundaries of what is expected by C&#43;&#43;  thread functions.</p>
</div>
<div class="paragraph">
<p>Now to handle the protection part, we need system dependent primitives to enable/disable runnning of tasks. These are 2 functions that will be a customization point. It is expected that on a microcontroller they will map to e.g. enable/disable_irq functions or similar.
Also the call to synchronize memory should be a customization point since many microcontrollers have much stronger memory subsystems compared to the general case for C/C&#43;&#43;.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// Interface to our cover class.
template&lt;typename System&gt;
class cover : System
{
public:
    // Called by low priority task to start/end a critical section.
    void protect() { System::protect(); }
    void unprotect() { System::unprotect(); }

    // Called by a high priority task to start/end a synchronization region.
    void sync() { System::sync(); }
    void unsync() { System::unsync(); }
};</pre>
</div>
</div>
<div class="paragraph">
<p>As can be seen, the asymmetric relationsship means 2 different sets of functions.
The Protect set does double duty of protecting a section of code and forming synchronization of variables inside. The sync variants only performs the synchronization.</p>
</div>
<div class="paragraph">
<p>In addition we want the traditional RAII style lock/unlock classes.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>template&lt;typename Cover&gt;
class protect_lock {
    protect_lock(Cover&amp; c) : m_c(c) { c.protect(); }
    ~protect_lock() { c.unprotect(); }
private:
    Cover&amp; m_c;
};

template&lt;typename Cover&gt;
class sync_lock {
    sync_lock(Cover&amp; c) : m_c(c) { c.sync(); }
    ~sync_lock() { c.unsync(); }
private:
    Cover&amp; m_c;
};</pre>
</div>
</div>
<div class="paragraph">
<p>So typical use of this would be to have your main() function constructing a protect_lock in a scope where it touches common data that an interrupt is also accessing. The interrupt in turn would use a sync_lock or a protect_lock depending on if it needs to protect from other interrupts or not.</p>
</div>
<div class="paragraph">
<p>Just using this, the following example should be viable on an ARM Cortex-M4 microcontroller:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>using Cover = cover&lt;armv7_m::cover&gt;;
static Cover cov;
static unsigned count;

extern "C" void SysTickHandler(void)
{
    sync_lock&lt;Cover&gt; lk(cov);
    count++;
}

int main()
{
    setupSysTick();
    while(1) {
        bool odd;
        {
            protect_lock&lt;Cover&gt; lk;
            odd = (count &amp; 1) != 0;
        }
        setLed(odd);
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Here we set up a SysTick interrupt function that should be called at regular intervals to update the count variable. The main loop busy polls this variable and does something with the value.
All the enable/disable interrupt and synchronization is now relegated to the cover class.
With the slightest of optimization turned on everything related to the cover is inlined
and we get the same code as by writing out all protection directly in the functions.</p>
</div>
<div class="paragraph">
<p>Now suppose we wanted to simulate this in a Linux environment. We set up some extra threads
with real time priority to act as interrupts. The only thing needed to change here is the cover class. The actual logic of the code stays unchanged.</p>
</div>
</div>
<div class="sect2">
<h3 id="_case_study_requirements_on_the_armv7_m_platform">Case study, requirements on the ArmV7-M platform.</h3>
<div class="paragraph">
<p>So assume we have our cortex-m4 microcontroller. This implements the ARMv7-M architecture which specifices all the fine print regarding hardware memory models, assembler instructions sets etc. What is needed to make this work?
First off, I assume a gcc compiler. It is the collaboration between the compiler and the actual hardware that is 'the other side' of the programming language specification.
So for the protection part, we will keep it simple and globally do enable/disable interrupt.
You can get fancy and use e.g. device specific interrupt blocking och blocking below a threshold, but it is overkill. Do note that several types of covers using different strategies can coexist in a program.
So the following could work:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// ARMV7-M implementation of cover
namespace armv7-m {
class cover
{
public:
    void protect() { __disable_irq(); sync(); }
    void unprotect() { unsync(); __enable_irq(); }

    void sync() { std::atomic_thread_fence(std::memory_order::acquire); }
    void unsync() { std::atomic_thread_fence(std::memory_order::release); }
};
}</pre>
</div>
</div>
<div class="paragraph">
<p>The standard fences will be compiled into an assembly instruction 'dmb ish' which
tells the hardware to sync up its memory before continuing. Both the acquire and release
are treated the same way. The compiler will also know that this is an externally visible effect so it won&#8217;t reorder memory accesses past this point.
The enable_irq and disable_irq are supplied by ARM specific headers and inserts assembler
instructions 'cpsie' and 'cpsid'.</p>
</div>
<div class="paragraph">
<p>So compiling this will generate code with proper disabling of interrupts and synchronization
via 'dmb ish'. But looking at the disassembly, it does seem a bit exessive. There are a number of unneeded 'dmb ish' instructions.</p>
</div>
<div class="paragraph">
<p>If one further studies the ARMv7-M manual one realizes that the cpsie, cpsid assembly instructions will perform all the needed hardware memory synchronization. Further, an interrupt will make the memory subsystem consistent.
However, we are not sure that the enable/disable interrupts are valid compiler barriers.
All the compiler know if that our variables are regular memory accesses that should not be affected by whatever assembly we insert. So to be on the safe side we should use a compiler barrier. For gcc it could look like:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>__asm__ volatile("": : :"memory");</pre>
</div>
</div>
<div class="paragraph">
<p>It is an inline assembly call without any instructions. But since it is volatile, gcc will not move load and stores of memory across it and inside our protected section. Do note that this is invisible at runtime, it only affects how the code is layed out at compile time.</p>
</div>
<div class="paragraph">
<p>A sidenote: there exist an std::atomic_signal_fence in addtion to std::atomic_thread_fence. It has a similar function but requires the synchronization to be done between a thread and a signal_handler on the same stack. If we can guarantee that, it can be useful. Using this when we simulate interrupts with another thread would be illegal. Also, equating a C/C&#43;&#43;  signal handler (a unix concept)  with a microcontroller interrupt service routine is probably true, but I have not seen a definite statement that it is. It is a grey area.</p>
</div>
<div class="paragraph">
<p>So, this cover implementation should suffice and generate less code:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// ARMV7-M implementation of cover, improved.
namespace armv7-m {
class cover
{
public:
    void protect() { __disable_irq(); sync(); }
    void unprotect() { unsync(); __enable_irq(); }

    void sync() { __asm__ volatile("": : :"memory"); }
    void unsync() { __asm__ volatile("": : :"memory"); }
};
}</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_linux_simulation_case">Linux simulation case</h3>
<div class="paragraph">
<p>In the case of a Linux simulation we do not have interrupts, rather we use threads to simulate them. Even if we have real time threads, we can actually lock them in this case. Hence the easy
way here is to implement the cover in terms of a mutex.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// Linux implementation of cover.
namespace linux {
class cover
{
public:
    void protect() { m_.lock(); }
    void unprotect() { m_.unlock(); }

    void sync() { m_.lock(); }
    void unsync() { m_.unlock(); }
private:
    std::mutex m_;
};
}</pre>
</div>
</div>
<div class="paragraph">
<p>Here we rely on interrupts being simulated by a thread and can be blocked so a mutex is ok. At the same time we fall back to the mutex to provide all the guarantees needed to avoid data-races.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_atomic_variables">Atomic variables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to mutexes we have atomic variables. Looking at the standard atomics have the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Read an writes are atomic, that is observed from other threads, an operation is either fully seen or not at all. No sheared writes are seen.</p>
</li>
<li>
<p>An atomic is externally visible. A thread must assume some other tread can observe its value.</p>
</li>
<li>
<p>Depending on memory order, an operation on an atomic participate in inter thread synchronization.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So in our example, we could replace to 'count' variable with an atomic&lt;unsigned&gt; and then we could drop all the use of the Cover object.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>static std::atomic&lt;unsigned&gt; count;

extern "C" void SysTickHandler(void)
{
    // Note, can get away with several operations, since we know we block main fkn.
    auto t = count.load();
    count.store(++t);
}

int main()
{
    setSysTick();
    assert(atomic_is_lock_free(&amp;count));
    while(1) {
        bool odd = (count.load() &amp; 1) != 0;
        setLed(countodd);
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Less code which is good. Do note the assert in the main function. We need lock-free atomics
for this to work. The C&#43;&#43; standard says the compiler can insert locks to implement atomics.
For most systems where primitive read and writes are 'all or nothing' compilers will generate lock free accesses. But to be portable we need to check this.</p>
</div>
<div class="paragraph">
<p>How do we make sure we can always use atomic variables even when they are not lockless?
We need our own. Let it use the builtins if they work, but do a custom implementation if not.
We have previously used disable/enable interrupt to protect a memory area. Lets use that one.</p>
</div>
<div class="paragraph">
<p>What do we need:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For atomicity : all or nothing. If the particular system can not guarantee it, use disable/enable interrupt to allow the all or nothing guarantee.</p>
</li>
<li>
<p>For external visibility : We need some way to inform te compiler that a read/writes can be observed. One way to to achieve this are 'volatile' accesses or some other compiler dependent mean.</p>
</li>
<li>
<p>We need to look at the synchronization operation. We might need to use the fences to implement synchronization between threads and allow these to induce ordering between non atomic accesses on other variables.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_example_cortex_m3_or_armv7_m_architecture">Example: Cortex-M3, or ArmV7-M architecture.</h3>
<div class="paragraph">
<p>The Cortex-M3 is based on the ArmV7-M architecture. When gcc is used to compile code it claims
to always be lock free for primitive atomic types. So in this case, the builtin operations works. Do note tht this includes stuff like &#43;&#43; , &amp;=, etc. These are read/modify/write operations. How does the compiler do this?
It uses the special instructions LDREX, STREX. These are synchronization primitives where the LDREX loads a value and starts an exclusive transaction. STREX stores a value <em>if</em> nobody else have touched the target area since start. It returns a boolean telling if it succeeeded or not. Doing a small loop that test this and repeats on failue, you can get atomic multi-step operations.
If we use the compiler generated atomics we get all the other properties also (synchronization etc) for free.</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_cortex_m0_or_armv6_m_architecture">Example: Cortex-M0, or ArmV6-M architecture.</h3>
<div class="paragraph">
<p>This architecture lacks the LDREX / STREX operations so atomics can not guarantee atomic operations on read/modify/write operations.
However the simple load/store of a value are atomic (if they are aligned). So here we probably need to implement our own atomic. The simple load and store works so simply do that. But read/modify/write operations would need to disable / enable interrupts to be atomically safe.
So here we will need to manually handle the externally visibility property (possibly using volatile).</p>
</div>
<div class="paragraph">
<p>For the Synchronization the Cortex-M0 is a very strongly coupled memory system so
a compiler barrier should suffice as synchronization.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reasoning from the C/C&#43;&#43; 11 standard memory models and comparing interrupts to threads we can derive some requirements that allow us to reason about interrupts within the standards.
This allow us to write fairly portable code and concentrate the system dependent parts into
synchronization primitives such as the Cover and atomic variables.
This opens the door to do Linux based simulation of microcontroller code.
We can also see that our synchronization primitives approaches the traditional enable/disable interrupts and volatiles when running on in-order microcontrollers such as the Cortex-M0.
However modern compilers do need compiler barriers and for more evolved microcontrollers there can be a need for memory synchronization (e.g. the "dmb ish" instruction.)
Do note that this assumes a C/C&#43;&#43;  standard of year 11 or later. The earlier standarda doesn&#8217;t touch on the subjects. They might work but don&#8217;t need to. Check your compiler manual.</p>
</div>
</div>
</div>
</div>

  <aside class="p-share">
  <a href="http://b.hatena.ne.jp/add?mode=confirm&url=https%3a%2f%2ffocused-pare-3555cf.netlify.com%2finterrupt_cpp%2f&title=Interrupts%20in%20standard%20C%2b%2b" title="はてなブックマーク" class="ht" target="_blank" rel="nofollow"></a>
  <a href="http://www.facebook.com/sharer.php?u=https%3a%2f%2ffocused-pare-3555cf.netlify.com%2finterrupt_cpp%2f&t=Interrupts%20in%20standard%20C%2b%2b" title="Facebookでシェア" class="fb" target="_blank" rel="nofollow"></a>
  <a href="http://twitter.com/intent/tweet?url=https%3a%2f%2ffocused-pare-3555cf.netlify.com%2finterrupt_cpp%2f&text=Interrupts%20in%20standard%20C%2b%2b&tw_p=tweetbutton" title="Twitterでシェア" class="tw" target="_blank" rel="nofollow"></a>
  <a href="https://plus.google.com/share?url=https%3a%2f%2ffocused-pare-3555cf.netlify.com%2finterrupt_cpp%2f" title="Google Plusでシェア" class="gp" target="_blank" rel="nofollow"></a>
  <a href="http://line.me/R/msg/text/?Interrupts%20in%20standard%20C%2b%2b https%3a%2f%2ffocused-pare-3555cf.netlify.com%2finterrupt_cpp%2f" title="LINEでシェア" class="ln" target="_blank" rel="nofollow"></a>
</aside>


  <footer class="article-footer">
    <section>
      <ol class="p-crumb">
        <li><a href="https://focused-pare-3555cf.netlify.com/">Software development musings</a></li>
        
        <li>Interrupts in standard C&#43;&#43;</li>
      </ol>

      
      
      
      
      
      
    </section>
  </footer>
</article>



  
  
  <section>
    <header><span>Latests</span></header>
    <ul class="p-articles thin">
      <li><article class="li sm article-ae82d399b20db4fbf2c1159dee28f6c6">
  <div class="header-wrapper">
    <a href="https://focused-pare-3555cf.netlify.com/frontmatter/" class="thumbnail" title="Article title here"></a>
    <header class="article-header">
      <div class="clearfix">
        <h2 class="title"><a href="https://focused-pare-3555cf.netlify.com/frontmatter/">Article title here</a></h2>
        <ul class="p-facts">
          <li><time datetime="2016-09-28T17:00:00JST">Sep 28, 2016</time></li>
          
          
        </ul>
      </div>
    </header>
  </div>
</article>
</li>
    </ul>
  </section>
  
</div>


    </main>

    

    <footer class="l-footer">
      <div class="l-container">
        <p><span class="h-logo">&copy; Software development musings</span></p>
        <aside>
          <p>Powered by <a href="https://gohugo.io/">Hugo</a>.</p>
          <p><a href="https://github.com/dim0627/hugo_theme_aglaus" class="h-logo">Aglaus</a> designed by <a href="http://yet.unresolved.xyz/">Daisuke Tsuji</a>.</p>
        </aside>
      </div>
    </footer>

    <a href="#" class="p-movetop" title="ページ上部へ戻る" rel="nofollow"></a>
  </body>
</html>

